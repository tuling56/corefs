## 数据结构之--树

[TOC]

### 基本树

> 树的定义

1.树是元素的集合
2.该集合可以为空，这是树中没有元素，我们称树为空数
3.如果该集合不为空，那么该集合有一个根结点，以及0个或者多个子树。根结点与它的子树的根结点用一个变相连

树的深度

从树根到任一结点n有唯一的一条路径，我们称这条路径的长度为结点n的深度或层数。根结点的深度为0，其余结点的深度为其父结点的深度加1。深度相同的结点属于同一层。

树具有递归特征

> 树的实现

方式1：每个结点存储元素自身和多个指向子节点的指针

一个父节点可能有大量的子节点，而另一个父节点可能只有一个子节点，而树的增删结点操作会让子节点的数目发生进一步的变化。这种不确定性，可能带来大量的内存相关操作，并且容易造成内容的浪费。

方式2：每个节点存储元素自身，一个指针指向第一个子节点，并有另一个指针指向该子节点的下一个兄弟节点。


### 二叉树

二叉树是一种特殊的树，二叉树的每个节点最多只能有2个子节点。
单次搜索的复杂度为n，一个有n个节点的二叉树，它的最小深度为log(n),最大深度为n。

![深度为n](http://images.cnitblog.com/blog/413416/201303/18192708-33f7275db8f04f29bceb101db8e363ed.png)

![深度为logn](http://images.cnitblog.com/blog/413416/201303/18193146-54c40b4027ff442fb3199543c7f42d8e.png)

#### 二叉搜索树

![二叉搜索树](http://images.cnitblog.com/blog/413416/201303/17001935-1b9faa8518a14f95b3bb9eb3083f683c.png)

在二叉树的基础上添加条件：每个及节点都不比他左子树的任意元素小，而且不比它的右子树的任意元素大。
二叉搜索树可以方便的实现搜索算法。在搜索元素x的时候，我们可以将x和根节点比较:

1. 如果x等于根节点，那么找到x，停止搜索 (终止条件)

2. 如果x小于根节点，那么搜索左子树

3. 如果x大于根节点，那么搜索右子树

二叉搜索树所需要进行的操作次数最多与树的深度相等。n个节点的二叉搜索树的深度最多为n，最少为log(n)。

```
    在二叉搜索树上实现搜索，插入，删除，寻找最大最小节点的操作，每个节点中存有三个指针，一个指向父节点，一个指向左子节点，一个指向右子节点。

(这样的实现是为了方便。节点可以只保存有指向左右子节点的两个指针，并实现上述操作。)

难点在二叉搜索树的删除
```


#### 二叉平衡树
### AVL树
单次搜索的复杂度为log(n)

### 伸展树

对于m次连续搜索操作有很好的效率。

伸展树会在一次搜索后，对树进行一些特殊的操作，这些操作的理念与AVL树有些类似，即通过旋转来改变书节点的分布，并减小树的深度。但伸展树并没有AVL的平衡要求，任意及诶单的左右子树可以相差任意深度。与二叉搜索树类型，伸展树的单次搜索也可能需要n次操作。但伸展树可以保证，m次的连续搜索操作的复杂度为mlog(n)的量级，而不是mn量级。


### 哈弗曼树

待完成

## 参考

//待完成